#Hoisting
  Hoisting(호이스팅)이란?
    선언부의 코드가 맨 위로 끌어올려지는 것처럼 동작하는 자바스크립트의 특징으로 실제로 코드가 이동하는 것은
    아니지만, 엔진이 실행 전에 변수와 함수의 선언을 미리 메모리에 등록시켜 두어서 발생하는 현상이다.

#동기와 비동기
  동기(Synchronous) 처리란?
    작성된 코드의 순서대로 한 줄 씩 실행되며 이전의 작업이 끝나야 다음 작업을 진행하는 처리 방식이다.
  비동기(Asynchronous) 처리란?
    다른 작업을 동시에 실행하며 작업이 처리되는 대로 결과를 반환한다.
  -> 비동기 처리를 하는 이유는 웹 브라우저는 한 번에 한 작업만 처리할 수 있는 단일 스레드(Single Thread) 로 동작하기 때문이다.
  네트워크 요청 같은 시간이 오래 걸리는 작업을 동기 처리 하면 작업이 끝날 때 까지 UI가 멈춘다. 따라서 비동기 방식을 사용하여 원활하게 작업할 수 있도록 한다.

#this
  객체는 상태와 동작을 가진 자료구조다. 
  동작은 상태를 변경할 수 있어야 한다. 
  그러려면 메서드는 객체를 참조할 수 있어야 하는데 이러한 자기 참조 변수를 대부분의 프로그래밍 언어에서는 this로 정의한다. 

  단, 자바스크립트에서 this는 언제나 자기 참조 변수를 의미하지 않는다. 문맥에 따라서 변한다. 

  1. 일반 함수에서 this : 비엄격 모드에서는 전역 객체로 바인딩된다. 엄격 모드에서는 undefined이다. 
  2. 생성자 함수에서 this : 미래에 생성될 인스턴스를 의미한다. 
  3. 메서드에서 this : 자기 참조 변수를 의미한다. 
  4. call, apply, bind로 호출된 함수에서 this : 첫번째 인자로 넘겨준 객체가 this로 바인딩된다. 
  5. 이벤트 핸들러에서 this : 이벤트를 위임한 객체(e.currentTarget)로 바인딩된다. 

#var vs let vs const 차이

  1. 스코프 
  ##var — 함수 스코프

    함수 안에서만 범위가 구분됨
    블록({})은 무시됨

     ex)
        if (true) {
            var x = 10;
        }
        console.log(x); // 10 

  ##let, const — 블록 스코프

    {} 안에서만 유효

    ex)
       if (true) {
            let y = 20;
            const z = 30;
       }
       console.log(y); // 에러
       console.log(z); // 에러

   2. 재선언/재할당

      키워드	| 재선언	| 재할당
        var    가능	   가능
        let	   불가	   가능
       const	 불가	   불가

   3. 호이스팅(Hoisting)
     ##var

      선언이 최상단으로 끌어올려짐
      초기값은 undefined

      console.log(a); // undefined
      var a = 10;

    ##let, const

      호이스팅은 되지만 선언 전 접근 불가

      console.log(b); // 에러
      let b = 10;

#== vs ===

    "=="는 동등 연산자로, 두 값을 비교할 때 형변환(type coercion)을 수행한다.
     즉, 비교하는 값의 데이터 타입이 다르더라도 자동으로 형변환을 수행한 후에 비교한다. 이러한 형변환은 때로 예측하지 못한 결과를 초래할 수 있으므로, "=="를 사용할 때는 조심해야 한다. 
    
    "==="는 일치 연산자로, 두 값이 데이터 타입과 값이 모두 같은지 비교한다.
     따라서 "==="를 사용하면 형변환 없이 정확한 값을 비교할 수 있다. 이러한 일치 연산자를 사용하는 것이 더 안전하고 예측 가능한 결과를 얻을 수 있다.

#null vs undefined

     ##null
       값이 없다
       의미 : “여기에는 값이 없다” 라고 의도적으로 표현
    
##undefined
       아직 값이 정해지지 않았다
       의미 : 변수가 선언만 되고 값이 할당되지 않은 상태

     null과 undefined는 ===으로 비교함

#debounce vs throttle

  ##debounce
  이벤트가 연속으로 발생해도, 멈춘 뒤에 딱 한 번 실행한다.

   동작 방식
	    1.	이벤트 발생
	    2.	타이머 시작
    	3.	그 안에 또 이벤트 발생 → 기존 타이머 취소 & 다시 시작
    	4.	이벤트가 멈춘 뒤 N ms 후 실행
  
   ##throttle
   이벤트가 계속 발생해도, 일정 시간마다 한 번씩 실행한다.

    동작 방식
	     1.	이벤트 발생 → 즉시 실행
    	 2.	일정 시간 동안 추가 이벤트 무시
	     3.	시간이 지나면 다시 실행 가능

#브라우저 렌더링 원리

  브라우저 렌더링은 HTML, CSS, JavaScript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정이다.
  브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성된다.

  먼저 DOM을 생성한다.
    브라우저는 HTML 문서를 파싱하여 DOM 트리를 생성한다. 이때, HTML 태그를 노드로 변환하고, 노드간의 계층 관계를 형성한다.
  두 번째로 CSSOM을 생성합니다. 
    브라우저는 CSS 파일을 파싱하여 CSSOM 트리를 생성한다. 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성한다.
  세 번째로 DOM트리와 CSSOM을 결합하여 렌더 트리를 생성한다. 이때, 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성한다.

  이제, 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정을 거치게 된다. 
    이때, 요소의 배경, 테두리, 글자 등을 그리게 된다.

#프론트엔드 최적화

  1. 번들 & 로딩 최적화
		1) 코드 스플리팅(Code Splitting)
			필요할 때만 js를 로드한다.
		2) Tree Sharking
			사용하지 않는 코드를 제거한다.
			EMS(import/export) 사용이 핵심이다.
		3) 번들 크기 줄이기
			무거운 라이브러리 점검한다.
  2. 렌더링 성능 최적화
        1) 불필요한 리렌더 줄이기
        2) 렌더링할 DOM 양 줄이기
        3) 작업을 나눠 메인 스레드 덜 막기
        4) 로딩/번들 최적화
        5) CSS/레이아웃 관점 최적화
  3. 이벤트 & 인터랙션 최적화
		1) 이벤트 핸들러 최적화
			Debounce vs Throttle
		2) 리렌더 최소화
			(1) useCallback
			(2) React.memo
			(3) 이벤트 안에서 setState 최소화
        3) 스크롤 & 애니메이션 최적화
            (1) requestAnimationFrame 사용
            (2) CSS transform 사용
            (3) will-change 최소화
        4) 이벤트 위임 (Event Delegation)
            리스트에 이벤트 여러 개 달지 않고 부모에 하나만 달기
        5) Passive Event Listener 사용
            스크롤 성능 개선
        * React Native에서 인터랙션 최적화
            (1) FlatList 사용
            (2) keyExtractor 명확히
            (3) InteractionManager 사용
  4. 네트워크 & 데이터 최적화
        1) api 호출 줄이기
            debounce를 사용하거나 중복 요청을 방지하는 등의 방법을 이용
        2) 캐싱 전략
            http 캐싱, 클라이언트 캐싱 활용
        3) 데이터 크기 줄이기
            필요한 필드만 요청해서 받거나 압축을 사용하고 pagination을 필수로 함
        4) 요청 병렬 처리
        5) lazy loading
            (1) 이미지 지연 로딩
            (2) 코드 스플리팅
        6) api 구조 개선
        7) 네트워크 성능 확인
  5. 이미지 & 리소스 최적화
        1) 이미지 용량 줄이기
        2) 크기 최적화
        3) lazy loading
        4) CDN 사용
        5) Skeleton / Blur-up 전략
        6) 아이콘 SVG
        7) 불필요한 리렌더 방지
  6. 브라우저 랜더링 이해 기반 최적화
  7. 측정 & 분석
