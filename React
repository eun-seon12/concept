#클래스형 컴포넌트와 함수형 컴포넌트

  ES6에서 제공되는 클래스 문법을 이용해 렌더링 될 컴포넌트를 정의하는 방법을 제공한다.
  클래스 내부에 render() 함수는 반드시 작성되어야 하며,
  반환값으로는 렌더링 될 리액트 엘리먼트들을 정의한다. (일반적으로 JSX 사용) 

  JSX만으로도 리액트 엘리먼트를 정의할 수 있지만 클래스형 컴포넌트를 작성하게 되면 여러가지 장점이 있다.
  중복되는 엘리먼트들을 추상화해서 컴포넌트로 작성하고, 작성된 컴포넌트를 재사용하는 것이 리액트가 추구하는 방향이다.

  컴포넌트를 정의하는 방법은 두 가지가 있다

    - 함수형 컴포넌트
      클래스형 컴포넌트에 비해 더 간결하게 작성이 가능하고 선언하기도 편하며 메모리도 덜 사용하기에 권장되는 방식이고 함수의 반환값으로 ReactElement만 정의해서 반환하면 된다.
    - 클래스형 컴포넌트
      함수형 컴포넌트에서는 사용 불가능한 유상태 컴포넌트(state)의 사용이나 라이프 사이클 기능 임의의 메소드 정의하는 등이 가능하다.
      -> 이러한 함수형 컴포넌트의 기능적 한계로 훅스(hooks)를 제공하고 있다.

#useEffect

  useEffect는 기본적으로 마운트 된 시점과 업데이트 된 시점 두 가지 모두 동작하게 된다.
    마운트 될 때만 동작하고 업데이트 시에는 동작하지 않게 컨트롤 할 수도 있다. 
    마운트 : DOM이 생성되고 웹 브라우저상 나타나는 것

  useEffect(
                () => console.log('마운트 시점에만 동작함...'),
                []  // 빈 배열 안에 무언가 있다면 이전과 이후를 비교하여 같지 않은 경우에 다시 동작 시키지만
                    // 현재는 비교 대상이 없어서 마운트 시점에만 동작한다. (의존성 배열)
            )

#useState
 useState는 현재 상태 값(state)과 해당 값을 업데이트하는 함수(setState)를 배열로 반환한다.
 컴포넌트의 동적인 값을 저장하고 관리하는 데 사용된다.


#await
  await의 두가지 기능
            1. await가 달린 함수의 결과 promise에 담긴 결과를 반환한다.
            2. await가 달린 비동기 처리들은 동기식으로 동작하게 한다.


#redux

  redux(리덕스)는 상태를 관리하기 위한 라이브러리로 앱의 모든 상태는 하나의 저장소(store) 안에 있는 객체 트리에 저장된다.
  상태 트리를 변경하는 유일한 방법은 어떤 행동이 일어날 지 해당하는 action이고 action에 따라 상태를 어떻게 변경할 지를 명시하기 위해 reduce 함수를 작성한다.

  redux의 3가지 원칙
  1. 스토어라는 하나뿐인 데이터 공간을 이용하기 때문에 신뢰할 수 있는 데이터이다.
  2. 리덕스에서는 액션을 전달하는 리듀서 함수를 이용해서만 상태를 변경하며 직접 state를 변경하지 못한다.
  3. 변경은 오직 순수 함수로만 가능하다. (이 때문에 리듀서를 이용함)

  앱의 상태를 보관하는 store는 subscribe, dispatch, getState api를 제공한다.

  dispatch는 리듀서 함수를 호출하며, state의 현재 상태가 리듀서에 자동으로 전달되며 호출된다.
  state를 변경하는 유일한 방법은 dispatch를 통해 리듀서에게 액션을 보내는 것 뿐이다.
